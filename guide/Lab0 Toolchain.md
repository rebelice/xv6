# 0 Lab 0 Toolchain

`Week One`

[TOC]

## 0.1 Introduction

### 0.1.1 Objectives

This Lab concentrates on getting basic knowledge about working environment and toolchain for rest Labs. It introduces compiler tools, `qemu`, `gdb`,`git`, and x86 bare metal programming. 

### 0.1.2 Materials

You need the following tools:
- Unix-like system
- GCC
- GNU make
- git
- qemu
- gdb
We will introduce them below.

## 0.2 Compiler Toolchain

A compiler toolchain is the set of programs that transform your code into executable binaries. More specifically, for our purpose, it includs a C compiler, an assembler, and a linker to generate a 32-bit ELF binary targe ting on Intel architectures, i.e. x86 machines. 

For convenience, we recomend that you set your working environment based on a Linux distribution. In following presentation, we use Ubuntu 16.04 as such a platform.

From a canonical Ubuntu desktop installation, you need to parepare your compiler toolchain by issuing following command

```shell
$ sudo apt-get install -y build-essential gdb
```

If you are using a 64-bit machine, you may also need to install a 32-bit compatiable library, 

```shell 
$ sudo apt-get install gcc-multilib
```

Having issued above commands, you will get your compiler toolchain ready. This can be validated by testing

```shell
$ objdump -i
```

that displays `elf32-i386` near the 5th line, and issuing

```shell
$ gcc -m32 -print-libgcc-file-name
```

that returns something like `/usr/lib/gcc/x86_64-linux-gnu/5/32/libgcc.a`.

Of course, alternative approaches exist to prepare your working envirnment. For example, for those technology enthusiast, they can build the toolchain from source code, or, for those Enthusiast, they can download virtual machine image. For detail guidance, please refer to the [Tools.md](https://pdos.csail.mit.edu/6.828/2018/tools.html) document for further information.

## 0.3 QEMU Emulator
[QEMU](https://www.qemu.org/index.html) is a modern and fast PC emulator. We will use qemu instead of the demoboard for our project. Here you need to install it.

### 0.3.1 Install QEMU

On Ubuntu Linux, try this:
```shell
sudo apt-get install qemu
```

To test installation, try the following commands:
```shell
qemu-system-i386 -curses
```

It should display a bunch of messages, ending with "No bootable device". That's ready for your working.

## 0.4 Git

You can skip this step if you are familiar with git. **But you still need to complete the exercise.**

The files you will need for this and subsequent lab assignments in this course are distributed using the [Git](https://www.git-scm.com/) version control system. To learn more about Git, take a look at the [Git user's manual](https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html).

To install the files for lab 0, you need to *clone* the course repository.
```shell
git clone https://github.com/rebelice/xv6
```
And then enter the directory and switch branches to *lab0*.
```shell
cd xv6
git checkout lab0
```

### 0.4.1 Exercise 1

Ensure that you are in the xv6 directory of the lab0 branch. And then complete the following tasks  in order.

1. Create a new branch named *dev* and switch to it.
2. Add your name and school ID to the README.md.
3. Use *git status* to view status.
4. Use *git add* and *git commit* to commit your changes with message "My solution for lab0 exercise 1".
5. Merge the *dev* branch into the *lab0* branch.
6. Use *git log* to view logs.

If you're new to *Git*, make sure you understand these commands:
- git brahch
- git checkout
- git add
- git commit
- git merge
- git push
- git pull
- git clone
- git log
- git status

## 0.5 GNU Make

The make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. We use *GNU Make* to manage our project, so you need to know how it works. The [manual](https://www.gnu.org/software/make/manual/make.html) is fully introduced.

There is a simple example in the *xv6/simple*.

You need a file called a *makefile* to tell make what to do. Most often, the makefile tells *make* how to compile and link a program. A simple makefile consists of "rules" with the following shape:
```
<target>: <prerequisites>
 [tab] <recipe>
 ......
```
A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as *clean*.

A prerequisite is a file that is used as input to create the target. A target often depends on several files.

A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! 

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target *clean* does not have prerequisites.

A rule, then, explains how and when to remake certain files which are the targets of the particular rule. Make carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action. 

A makefile may contain other text besides rules, but a simple makefile need only contain rules. 

### 0.5.1 Exercise 2

Please add a new rule in xv6/simple/Makefile as described below.
When executing *make help*, tell me your name and school ID.

## 0.6 Bare Metal Program

In computer science, bare machine (or bare metal) refers to a computer executing instructions directly on logic hardware without an intervening operating system.  This means that operating system is a bare metal program.

Here you need to complete *helloworld* in bare metal environment.

### 0.6.1 BIOS

Floppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk's minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector.

When an x86 PC boots, it starts executing a program called the BIOS (Basic Input/Output System), which is stored in non-volatile memory on the motherboard. The BIOS's job is to prepare the hardware and then transfer control to the operating system. Specifically, it transfers control to code loaded from the boot sector, the first 512-byte sector of the boot disk. The BIOS loads the boot sector at memory address 0x7c00, checks magic numbers and then jumps to that address.  For historical reasons, the processor is in real mode while executing the code at 0x7c00. This means that you can only run 16-bit code.

Here we use QEMU to run our code. QEMU is a modern and fast PC emulator.  The [QEMU document](https://qemu.weilnetz.de/doc/qemu-doc.html) is fully introduced.

Now, recall magic numbers.  On i386-architecture machines, the magic numbers are 0x55 and 0xaa, respectively at the 511th and 512th bytes of the sector.

The assembly code compiled by gcc, because there is an *ELF* header part, and the offset of the code is not determined, we have to extract the code we need through the *objcopy* command. The specific commands are as follows:
```shell
objcopy -O binary (ELF Filename) (BIN Filename)
```
With this command, the executable part of the code can be extracted from the file in elf format. After that, we need to extend the code to one sector size (512 bytes) and add the magic numbers to the last two bytes. We have provided a script to do this work.  See details in */xv6/helloworld/sign.pl*. Obviously, since the BIOS only reads sector 0, our code size cannot exceed 1 sector size(512 bytes).

### 0.6.2 Print

How to output characters to the screen without an operating system? This is actually a very difficult thing. The main source of this difficulty is that there is no suitable way for the experiment to access the screen for output. In the actual operating system, the output of a string of characters in the experiment needs to pass through the display driver, the terminal and other parts. For ease of implementation, this lab will implement the operation of outputting characters in a very simplified way. We select the serial port that can be directly converted to the screen output, and implement its initialization and output part.

In order to understand the code, you need to know about the [linker scripts](https://sourceware.org/binutils/docs/ld/Scripts.html)

### 0.6.3 Exercise 3

According to the code, what does *serial_putc* do? Briefly explain.

## 0.7 GDB with QEMU

Learning by doing! Please follow the steps to complete *Exercise 4*.

### 0.7.1 Exercise 4

Read part 2.15 GDB Usage of the [qemu-doc](https://qemu.weilnetz.de/doc/qemu-doc.html#Debug_002fExpert-options)
For the gdb command, you can refer to the [GDB online docs](https://sourceware.org/gdb/current/onlinedocs/gdb/)

1. Run *make* to compile source code.
2. Run and explain *make qemu-nox-gdb*.
3. Open another terminal and run *gdb*.
4. Let gdb connects to qemu.
5. Set breakpoint at 0x7c00.
6. Then Continue.
7. View the value of %esp and %ebp.

## 0.8 References

1. [Git user's manual](https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html);
2. [Gun make](https://www.gnu.org/software/make/manual/make.html)
3. [QEMU document](https://qemu.weilnetz.de/doc/qemu-doc.html)
4. [linker scripts](https://sourceware.org/binutils/docs/ld/Scripts.html)
5. [qemu-doc for gdb](https://qemu.weilnetz.de/doc/qemu-doc.html#Debug_002fExpert-options)
6. [GDB online docs](https://sourceware.org/gdb/current/onlinedocs/gdb/)